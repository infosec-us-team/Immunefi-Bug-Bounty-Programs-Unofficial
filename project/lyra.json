{
  "pageProps": {
    "type": "bounty",
    "bounty": {
      "id": "lyra",
      "slug": "lyra",
      "project": "Lyra",
      "maxBounty": 50000,
      "logo": "https://images.ctfassets.net/t3wqy70tc3bv/3rpp7fLPif0JTGLDDZO6l6/fe90db1d368b64cf2a361be7b5b90808/Lyra.jpeg",
      "launchDate": "2021-08-23T09:00-05:00",
      "updatedDate": "2023-01-16T02:51:21.020Z",
      "kyc": false,
      "rewards": [
        {
          "assetType": "smart_contract",
          "level": "critical",
          "payout": "USD $50,000",
          "pocRequired": false
        }
      ],
      "audits": null,
      "assets": [
        {
          "id": "4KG2zOc81FtLZhSHHSSjvZ",
          "type": "smart_contract",
          "url": "https://github.com/lyra-finance/lyra-protocol/blob/master/contracts/SynthetixAdapter.sol",
          "description": "SynthetixAdapter.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "3gOovTc0UywbiVaggEBpti",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0x5Db73886c4730dBF3C562ebf8044E19E8C93843e#code",
          "description": "LiquidityPool.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "7yTVTSfpTFHaCVSnQU6iNF",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0x0d1a91354A387a1e9E8FCD8f576670c4C3b723cA#code",
          "description": "LiquidityToken.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "5DwfAgtp4Mka4Wz0UBQrzB",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0xbb3e8Eac35e649ed1071A9Ec42223d474e67b19A#code",
          "description": "OptionGreekCache.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "2TaCbiV530qYX109xBj5xN",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0x1d42a98848e022908069c2c545aE44Cc78509Bc8#code",
          "description": "OptionMarket.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "6zonwlMdstTAOUz6QYvlBt",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0x73b161f1bcF37048A5173619cda53aaa56A28Be0#code",
          "description": "OptionMarketPricer.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "1A61dU93c0nHu4Pcexkcvl",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0xCfDfF4E171133D55dE2e45c66a0E144a135D93f2#code",
          "description": "OptionToken.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "zVmnKALx5695qnfea516K",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0x3E86B53e1D7DA7eDbA225c3A218d0b5a7544fDfD#code",
          "description": "ShortCollateral.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "4IlPLlXHvRHUh6Yf6itatP",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0x60a5159bAfb2198b967021AC77E26C1417081477#code",
          "description": "ShortPoolHedger.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "4e8KJdnTqiU1HmXkGkFfLx",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0xE97831964bF41C564EDF6629f818Ed36C85fD520#code",
          "description": "BlackScholes.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "4LptlgVBvCXUe67xYiQubm",
          "type": "smart_contract",
          "url": "https://github.com/lyra-finance/lyra-protocol/blob/master/contracts/libraries/FixedPointMathLib.sol",
          "description": "FixedPointMathLib.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "333kuofJ6pzl9wa1uSQIm1",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0xe0392ea1bABCf15d95819A5Bfc68aC191DF39C5B#code",
          "description": "GWAV.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "64pXlmOb6f9IJGXiWBx0dU",
          "type": "smart_contract",
          "url": "https://github.com/lyra-finance/lyra-protocol/blob/master/contracts/libraries/PoolHedger.sol",
          "description": " PoolHedger.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "17lXMmm1BJNuAZVdVDY07N",
          "type": "smart_contract",
          "url": "https://github.com/lyra-finance/lyra-protocol/blob/master/contracts/libraries/SimpleInitializeable.sol",
          "description": "SimpleInitializeable.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "M4eJdVfbZOB1PO22gzOVV",
          "type": "smart_contract",
          "url": "https://github.com/lyra-finance/lyra-protocol/blob/master/contracts/synthetix/Owned.sol",
          "description": "Owned.sol",
          "isPrimacyOfImpact": null
        },
        {
          "id": "5PmilXjhTVy56zvLEiBxW3",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0xEAf788AD8abd9C98bA05F6802a62B8DbC673D76B#code",
          "description": "OptionMarketViewer",
          "isPrimacyOfImpact": null
        },
        {
          "id": "3C15HbXH9yUv7DtgpEdujl",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0xCCE7819d65f348c64B7Beb205BA367b3fE33763B#code",
          "description": "OptionMarketWrapper",
          "isPrimacyOfImpact": null
        },
        {
          "id": "61I2ooDHvU8bvTlfk0ZRh8",
          "type": "smart_contract",
          "url": "https://optimistic.etherscan.io/address/0xF5A0442D4753cA1Ea36427ec071aa5E786dA5916#code",
          "description": "LyraRegistry",
          "isPrimacyOfImpact": null
        }
      ],
      "impacts": [
        {
          "id": "6Si7GAaONFpvncUSOW6lha",
          "title": "Direct theft of any user funds, whether at-rest or in-motion, other than unclaimed yield",
          "type": "smart_contract",
          "severity": "critical"
        },
        {
          "id": "7Amq3OkHUrvqyt0wcPAB5h",
          "title": "Permanent freezing of funds",
          "type": "smart_contract",
          "severity": "critical"
        },
        {
          "id": "4zdSVhc8VPbiVAJV3QvVJ2",
          "title": "Theft of unclaimed yield",
          "type": "smart_contract",
          "severity": "critical"
        },
        {
          "id": "UUDFoXsj7TNG9Xk5chzo9",
          "title": "Permanent freezing of unclaimed yield",
          "type": "smart_contract",
          "severity": "critical"
        }
      ],
      "programOverview": "Lyra uses a dynamic volatility input to price the entire options surface using a Black Scholes model. Current implementations use a static IV or other, less accurate workarounds to price options. Lyra is also the first options AMM to compose with other DeFi projects to automatically price and hedge risk for LPs. The reduced risk allows LPs to feel comfortable to provide deeper liquidity, yielding more trading volume and higher fees.\n\nFor more information about Lyra, please visit [https://www.lyra.finance/](https://www.lyra.finance/).     \n",
      "prioritizedVulnerabilities": "We are especially interested in receiving and rewarding vulnerabilities of the following types:\n\n__Smart Contracts and Blockchain__ \n\n  - Re-entrancy\n  - Logic errors\n    - including user authentication errors\n  - Solidity/EVM details not considered\n    - including integer over-/under-flow\n    - including rounding errors\n    - including unhandled exceptions\n  - Trusting trust/dependency vulnerabilities\n    - including composability vulnerabilities\n  - Oracle failure/manipulation\n  - Novel governance attacks\n  - Economic/financial attacks\n    - including flash loan attacks\n  - Congestion and scalability\n    - including running out of gas\n    - including block stuffing\n    - including susceptibility to frontrunning\n  - Consensus failures\n  - Cryptography problems\n    - Signature malleability\n    - Susceptibility to replay attacks\n    - Weak randomness\n    - Weak encryption\n  - Susceptibility to block timestamp manipulation\n  - Missing access controls / unprotected internal or debugging interfaces",
      "rewardsBody": "Rewards are distributed according to the impact of the vulnerability based on the [Immunefi Vulnerability Severity Classification System V2.2](https://immunefi.com/immunefi-vulnerability-severity-classification-system-v2-2). This is a simplified 5-level scale, with separate scales for websites/apps and smart contracts/blockchains, encompassing everything from consequence of exploitation to privilege required to likelihood of a successful exploit.\n\nAll High and Critical Smart Contract bug reports require a PoC to be eligible for a reward. Explanations and statements are not accepted as PoC and code is required.\n\nCritical smart contract vulnerabilities are capped at 10% of economic damage, primarily taking into consideration funds at risk, but also PR and branding aspects, at the discretion of the team. However, there is a minimum reward of USD __50,000__.\n\nCritical payouts by Sherlock will only be paid out for critical bugs that would result in a loss of funds and can be executed profitably, and this then excludes Sherlock critical bounty payout for temporary freezing bugs.  If further clarification is needed to decide on a Sherlock payout, the [coverage agreement](https://github.com/sherlock-protocol/sherlock-reports/tree/main/coverage-agreements) between Lyra and Sherlock should be referenced. \n\nRe-entrancy attacks are only considered valid submissions if it is assumed that all plugged in smart contracts are the synthetix contracts\n\nAny attack vectors that require a custom quote/base asset (Lyra’s units of account - sUSD/sETH for example) are not eligible for a reward.\n\nAny vulnerability already disclosed in the [audits that have been performed](https://github.com/lyra-finance/lyra-protocol/tree/master/audits) are not able to receive a reward.\n\nIssues identified in previous audit reports may not be eligible for payout. \n\nTo be eligible for reward, impact from table below must be demonstrated where all thefts must be profitable and all freezing must be reasonably priced for the impact.\n\nPayouts up to USD __50,000__ are handled by the __Lyra__ team directly and are denominated in USD. However, payouts are done in __USDC__ or __ETH__, at the discretion of the team. Payments above that have the remainder paid out by __Sherlock__ with their bug bounty matching program and are done in __USDC__. ",
      "outOfScopeAndRules": "The following vulnerabilities are excluded from the rewards for this bug bounty program:\n\n  - Attacks that the reporter has already exploited themselves, leading to damage\n  - Attacks requiring access to leaked keys/credentials\n  - Attacks requiring access to privileged addresses (governance, strategist)\n\nSmart Contracts and Blockchain\n\n  - Incorrect data supplied by third party oracles\n    - Not to exclude oracle manipulation/flash loan attacks\n  - Basic economic governance attacks (e.g. 51% attack)\n  - Lack of liquidity\n  - Best practice critiques\n  - Sybil attacks\n  - Centralization risks\n\nThe following activities are prohibited by this bug bounty program:\n\n  - Any testing with mainnet or public testnet contracts; all testing should be done on private testnets\n  - Any testing with pricing oracles or third party smart contracts\n  - Attempting phishing or other social engineering attacks against our employees and/or customers\n  - Any testing with third party systems and applications (e.g. browser extensions) as well as websites (e.g. SSO providers, advertising networks)\n  - Any denial of service attacks\n  - Automated testing of services that generates significant amounts of traffic\n  - Public disclosure of an unpatched vulnerability in an embargoed bounty",
      "assetsBodyV2": "All smart contracts of Lyra can be found at [[https://github.com/lyra-finance/lyra-protocol]](https://github.com/lyra-finance/lyra-protocol). However, only those in the assets in scope table are considered as in-scope of the bug bounty program. An exception to this are the libraries that are inherited from these contracts.\n\nThough only the proxy contracts are listed as in-scope, current implementation and any further updates to the implementation contracts are considered in scope. When reporting a bug, please make sure to select the relevant proxy smart contract as the target. \nIf an impact can be caused to any other asset managed by Lyra that isn’t on this table but for which the impact is in the Impacts in Scope section below, you are encouraged to submit it for the consideration by the project. ",
      "impactsBody": null,
      "immunefiStandard": true,
      "tags": {
        "productType": [
          "AMM"
        ],
        "projectType": [
          "Defi"
        ],
        "ecosystem": [
          "Optimism"
        ],
        "programType": [
          "Smart Contract"
        ],
        "language": [
          "Solidity"
        ]
      },
      "legacy": {
        "technologies": [
          "Smart Contract"
        ],
        "blockchain_rewards": [],
        "smartcontract_rewards": [
          {
            "level": "Critical",
            "payout": "USD $50,000"
          }
        ],
        "web_rewards": []
      }
    },
    "mdx": {
      "programOverview": {
        "compiledSource": "\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Lyra uses a dynamic volatility input to price the entire options surface using a Black Scholes model. Current implementations use a static IV or other, less accurate workarounds to price options. Lyra is also the first options AMM to compose with other DeFi projects to automatically price and hedge risk for LPs. The reduced risk allows LPs to feel comfortable to provide deeper liquidity, yielding more trading volume and higher fees.\"), mdx(\"p\", null, \"For more information about Lyra, please visit \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.lyra.finance/\"\n  }, \"https://www.lyra.finance/\"), \".     \"));\n}\n;\nMDXContent.isMDXComponent = true;",
        "renderedOutput": "<p>Lyra uses a dynamic volatility input to price the entire options surface using a Black Scholes model. Current implementations use a static IV or other, less accurate workarounds to price options. Lyra is also the first options AMM to compose with other DeFi projects to automatically price and hedge risk for LPs. The reduced risk allows LPs to feel comfortable to provide deeper liquidity, yielding more trading volume and higher fees.</p><p>For more information about Lyra, please visit <a href=\"https://www.lyra.finance/\">https://www.lyra.finance/</a>.     </p>",
        "scope": {}
      },
      "prioritizedVulnerabilities": {
        "compiledSource": "\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"We are especially interested in receiving and rewarding vulnerabilities of the following types:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Smart Contracts and Blockchain\"), \" \"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Re-entrancy\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Logic errors\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"including user authentication errors\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Solidity/EVM details not considered\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"including integer over-/under-flow\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"including rounding errors\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"including unhandled exceptions\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Trusting trust/dependency vulnerabilities\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"including composability vulnerabilities\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Oracle failure/manipulation\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Novel governance attacks\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Economic/financial attacks\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"including flash loan attacks\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Congestion and scalability\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"including running out of gas\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"including block stuffing\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"including susceptibility to frontrunning\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Consensus failures\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Cryptography problems\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Signature malleability\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Susceptibility to replay attacks\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Weak randomness\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Weak encryption\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Susceptibility to block timestamp manipulation\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Missing access controls / unprotected internal or debugging interfaces\")));\n}\n;\nMDXContent.isMDXComponent = true;",
        "renderedOutput": "<p>We are especially interested in receiving and rewarding vulnerabilities of the following types:</p><p><strong>Smart Contracts and Blockchain</strong> </p><ul><li>Re-entrancy</li><li>Logic errors<ul><li>including user authentication errors</li></ul></li><li>Solidity/EVM details not considered<ul><li>including integer over-/under-flow</li><li>including rounding errors</li><li>including unhandled exceptions</li></ul></li><li>Trusting trust/dependency vulnerabilities<ul><li>including composability vulnerabilities</li></ul></li><li>Oracle failure/manipulation</li><li>Novel governance attacks</li><li>Economic/financial attacks<ul><li>including flash loan attacks</li></ul></li><li>Congestion and scalability<ul><li>including running out of gas</li><li>including block stuffing</li><li>including susceptibility to frontrunning</li></ul></li><li>Consensus failures</li><li>Cryptography problems<ul><li>Signature malleability</li><li>Susceptibility to replay attacks</li><li>Weak randomness</li><li>Weak encryption</li></ul></li><li>Susceptibility to block timestamp manipulation</li><li>Missing access controls / unprotected internal or debugging interfaces</li></ul>",
        "scope": {}
      },
      "rewardsBody": {
        "compiledSource": "\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Rewards are distributed according to the impact of the vulnerability based on the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://immunefi.com/immunefi-vulnerability-severity-classification-system-v2-2\"\n  }, \"Immunefi Vulnerability Severity Classification System V2.2\"), \". This is a simplified 5-level scale, with separate scales for websites/apps and smart contracts/blockchains, encompassing everything from consequence of exploitation to privilege required to likelihood of a successful exploit.\"), mdx(\"p\", null, \"All High and Critical Smart Contract bug reports require a PoC to be eligible for a reward. Explanations and statements are not accepted as PoC and code is required.\"), mdx(\"p\", null, \"Critical smart contract vulnerabilities are capped at 10% of economic damage, primarily taking into consideration funds at risk, but also PR and branding aspects, at the discretion of the team. However, there is a minimum reward of USD \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"50,000\"), \".\"), mdx(\"p\", null, \"Critical payouts by Sherlock will only be paid out for critical bugs that would result in a loss of funds and can be executed profitably, and this then excludes Sherlock critical bounty payout for temporary freezing bugs.  If further clarification is needed to decide on a Sherlock payout, the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/sherlock-protocol/sherlock-reports/tree/main/coverage-agreements\"\n  }, \"coverage agreement\"), \" between Lyra and Sherlock should be referenced. \"), mdx(\"p\", null, \"Re-entrancy attacks are only considered valid submissions if it is assumed that all plugged in smart contracts are the synthetix contracts\"), mdx(\"p\", null, \"Any attack vectors that require a custom quote/base asset (Lyra\\u2019s units of account - sUSD/sETH for example) are not eligible for a reward.\"), mdx(\"p\", null, \"Any vulnerability already disclosed in the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/lyra-finance/lyra-protocol/tree/master/audits\"\n  }, \"audits that have been performed\"), \" are not able to receive a reward.\"), mdx(\"p\", null, \"Issues identified in previous audit reports may not be eligible for payout. \"), mdx(\"p\", null, \"To be eligible for reward, impact from table below must be demonstrated where all thefts must be profitable and all freezing must be reasonably priced for the impact.\"), mdx(\"p\", null, \"Payouts up to USD \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"50,000\"), \" are handled by the \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Lyra\"), \" team directly and are denominated in USD. However, payouts are done in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"USDC\"), \" or \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"ETH\"), \", at the discretion of the team. Payments above that have the remainder paid out by \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Sherlock\"), \" with their bug bounty matching program and are done in \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"USDC\"), \". \"));\n}\n;\nMDXContent.isMDXComponent = true;",
        "renderedOutput": "<p>Rewards are distributed according to the impact of the vulnerability based on the <a href=\"https://immunefi.com/immunefi-vulnerability-severity-classification-system-v2-2\">Immunefi Vulnerability Severity Classification System V2.2</a>. This is a simplified 5-level scale, with separate scales for websites/apps and smart contracts/blockchains, encompassing everything from consequence of exploitation to privilege required to likelihood of a successful exploit.</p><p>All High and Critical Smart Contract bug reports require a PoC to be eligible for a reward. Explanations and statements are not accepted as PoC and code is required.</p><p>Critical smart contract vulnerabilities are capped at 10% of economic damage, primarily taking into consideration funds at risk, but also PR and branding aspects, at the discretion of the team. However, there is a minimum reward of USD <strong>50,000</strong>.</p><p>Critical payouts by Sherlock will only be paid out for critical bugs that would result in a loss of funds and can be executed profitably, and this then excludes Sherlock critical bounty payout for temporary freezing bugs.  If further clarification is needed to decide on a Sherlock payout, the <a href=\"https://github.com/sherlock-protocol/sherlock-reports/tree/main/coverage-agreements\">coverage agreement</a> between Lyra and Sherlock should be referenced. </p><p>Re-entrancy attacks are only considered valid submissions if it is assumed that all plugged in smart contracts are the synthetix contracts</p><p>Any attack vectors that require a custom quote/base asset (Lyra’s units of account - sUSD/sETH for example) are not eligible for a reward.</p><p>Any vulnerability already disclosed in the <a href=\"https://github.com/lyra-finance/lyra-protocol/tree/master/audits\">audits that have been performed</a> are not able to receive a reward.</p><p>Issues identified in previous audit reports may not be eligible for payout. </p><p>To be eligible for reward, impact from table below must be demonstrated where all thefts must be profitable and all freezing must be reasonably priced for the impact.</p><p>Payouts up to USD <strong>50,000</strong> are handled by the <strong>Lyra</strong> team directly and are denominated in USD. However, payouts are done in <strong>USDC</strong> or <strong>ETH</strong>, at the discretion of the team. Payments above that have the remainder paid out by <strong>Sherlock</strong> with their bug bounty matching program and are done in <strong>USDC</strong>. </p>",
        "scope": {}
      },
      "outOfScopeAndRules": {
        "compiledSource": "\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"The following vulnerabilities are excluded from the rewards for this bug bounty program:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Attacks that the reporter has already exploited themselves, leading to damage\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Attacks requiring access to leaked keys/credentials\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Attacks requiring access to privileged addresses (governance, strategist)\")), mdx(\"p\", null, \"Smart Contracts and Blockchain\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Incorrect data supplied by third party oracles\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Not to exclude oracle manipulation/flash loan attacks\"))), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Basic economic governance attacks (e.g. 51% attack)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Lack of liquidity\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Best practice critiques\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sybil attacks\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Centralization risks\")), mdx(\"p\", null, \"The following activities are prohibited by this bug bounty program:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any testing with mainnet or public testnet contracts; all testing should be done on private testnets\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any testing with pricing oracles or third party smart contracts\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Attempting phishing or other social engineering attacks against our employees and/or customers\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any testing with third party systems and applications (e.g. browser extensions) as well as websites (e.g. SSO providers, advertising networks)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Any denial of service attacks\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Automated testing of services that generates significant amounts of traffic\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Public disclosure of an unpatched vulnerability in an embargoed bounty\")));\n}\n;\nMDXContent.isMDXComponent = true;",
        "renderedOutput": "<p>The following vulnerabilities are excluded from the rewards for this bug bounty program:</p><ul><li>Attacks that the reporter has already exploited themselves, leading to damage</li><li>Attacks requiring access to leaked keys/credentials</li><li>Attacks requiring access to privileged addresses (governance, strategist)</li></ul><p>Smart Contracts and Blockchain</p><ul><li>Incorrect data supplied by third party oracles<ul><li>Not to exclude oracle manipulation/flash loan attacks</li></ul></li><li>Basic economic governance attacks (e.g. 51% attack)</li><li>Lack of liquidity</li><li>Best practice critiques</li><li>Sybil attacks</li><li>Centralization risks</li></ul><p>The following activities are prohibited by this bug bounty program:</p><ul><li>Any testing with mainnet or public testnet contracts; all testing should be done on private testnets</li><li>Any testing with pricing oracles or third party smart contracts</li><li>Attempting phishing or other social engineering attacks against our employees and/or customers</li><li>Any testing with third party systems and applications (e.g. browser extensions) as well as websites (e.g. SSO providers, advertising networks)</li><li>Any denial of service attacks</li><li>Automated testing of services that generates significant amounts of traffic</li><li>Public disclosure of an unpatched vulnerability in an embargoed bounty</li></ul>",
        "scope": {}
      },
      "assetsBodyV2": {
        "compiledSource": "\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"All smart contracts of Lyra can be found at \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/lyra-finance/lyra-protocol\"\n  }, \"[https://github.com/lyra-finance/lyra-protocol]\"), \". However, only those in the assets in scope table are considered as in-scope of the bug bounty program. An exception to this are the libraries that are inherited from these contracts.\"), mdx(\"p\", null, \"Though only the proxy contracts are listed as in-scope, current implementation and any further updates to the implementation contracts are considered in scope. When reporting a bug, please make sure to select the relevant proxy smart contract as the target.\\nIf an impact can be caused to any other asset managed by Lyra that isn\\u2019t on this table but for which the impact is in the Impacts in Scope section below, you are encouraged to submit it for the consideration by the project. \"));\n}\n;\nMDXContent.isMDXComponent = true;",
        "renderedOutput": "<p>All smart contracts of Lyra can be found at <a href=\"https://github.com/lyra-finance/lyra-protocol\">[https://github.com/lyra-finance/lyra-protocol]</a>. However, only those in the assets in scope table are considered as in-scope of the bug bounty program. An exception to this are the libraries that are inherited from these contracts.</p><p>Though only the proxy contracts are listed as in-scope, current implementation and any further updates to the implementation contracts are considered in scope. When reporting a bug, please make sure to select the relevant proxy smart contract as the target.\nIf an impact can be caused to any other asset managed by Lyra that isn’t on this table but for which the impact is in the Impacts in Scope section below, you are encouraged to submit it for the consideration by the project. </p>",
        "scope": {}
      },
      "impactsBody": {
        "compiledSource": "\"use strict\";\n\nvar _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar layoutProps = {};\nvar MDXLayout = \"wrapper\";\nfunction MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }));\n}\n;\nMDXContent.isMDXComponent = true;",
        "renderedOutput": "",
        "scope": {}
      }
    },
    "project": null
  },
  "__N_SSG": true
}
